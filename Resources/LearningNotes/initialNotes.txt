In This repo I will be learning Vue.js starting with the fundamentals

Author: Troy Fournier

Vue.js Fundamentals
URL: https://app.pluralsight.com/course-player?course=vuejs-fundamentals&author=jim-cooper&name=138c402b-b8d3-4299-b4d6-e1341e451c40&clip=0&mode=live

Note:
    When picking up from where you leave off start the server again
    npm run serve


Overview
    starting with vue/cli
    Components
    Router
    Managing state
    Directives
    Filters
    Package and Deploy

Getting started with the vue cli
    Will be building Build-a-bot site

The Vue Instance
    Heart of the application 
    Created whenever you call new Vue()
        only used once in a typical vue application

    Usually tell it to render a component
    ex
        new Vue({render: h => h(App)})

    App will become the top level component in a hierarchy call Vue Structure

    wraps entire application, inside that will be app component
        App can have child component, which may have child components

    App will contain router vue which shows content for current URL
        as url changes it updates the content inside the router view

Setting up the environment
    install node
        Mac: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash

    nvm install 8.11.2
        using same version as course

    nvm use 8.11.2

Creating a new project with the vue cli
    Vue CLI recommended when creating a project to be deployed
        vue team has designed it to allow optimization for production

Generate project
    vue create build-a-bot
        creats a new vue project in the specified directory. In this case the build-a-bot directory

    allows for choosing features and installs npm depenencies

    setup eslint

Package.json
    brought in 3 scripts for us that call the vue cli server

    vue cli service manages a local dev webserver based on webpack
        more in another course

    npm run serve
        compiles application for development
        runs server for us on port 8080

    runs sample webpage for us

Main.js
    entry point for vue application

    creates a new vue Instance
    passes in options object

    configuring render property
        set to a function that is getting App component passed to it

App.js
    3 components to file
        Template
        Script
        Style

    Vue specific wepack plugin being used to parse file into indivdual parts and compile in a way a browser can use them
    Passed into vue instance so vue works with webpack to render

    This is the top level component in our App
        used to display route components and child components

    App is displaying HelloWorld as a child component
        components>HelloWorld.vue

Creating the Home Page
    replace generated content with our own
    Get us more familiar with what CLI generated

    Vue style guide rule
        Components should be two words at a minimum
    
    App element is refering to the div in the template with id="app"

    didn't need to hit refresh because vue cli is using webpack dev server including hot module replacement

Module 2
    Creating components
    Using bindings to display and handle events
    Conditionally displaying elements
        v-if and v-show
    Repeating elements with v-for
    Styling components
    Working with component lifecycle hooks
    Reducing duplication with mixins

Global Components vs Single-file Components

Components
    Really just another view instance
    easiest way to get something to render:
        new Vue({
            template: ''<div>Hello World</div>',
            el: '#app',
        });

        Creating a new instance of view
        Passing in a options object with a hello world template
        line 127 tells vue which element of the page to mount the template in

Global Components
    const World = Vue.component(
        'World',
        { template: '<span>World</span>' },
    );
    passing in the component name 'World'
    and the option object

Components are really just vue instances, with exception of the options object you pass in to the new component has the exact same properties as the one you pass in to a view instance

can now:
    new Vue({
            template: ''<div>Hello <World /></div>',
            el: '#app',
        });

World component is a Global Component
    just a World constant you can use anywhere you want.
    Useful in smaller applications and prototyping

Limitations
    Hard to locate
    Use string templates all HTML must be defined in Javascript string
    CSS is not encapsulated
    No build time compilation support

Single-file Components
    file with a .vue extension 
    
    typically 3 sections
        Template
            required
        Script
            required
        Style
            optional

Template section
    Where we define HTML template

Script section
    define Javascript functionality of component
    export it so it can be imported else where

Style Section
    where we define css

vue files compiled by webpack at runtime to create JS, CSS, and HTML files for the browser

App.vue is a Single-file component

Creating your First Component

    Created robot builder component
        all we have done is export it and use it in the App.vue

Binding Attributes to Data with v-bind

    component options need a data function to have data provided to a component

    made a data folder
    made a json file that contains all of the parts data in the data folder
        mostly json data

    first line parts.js
    const images = require.context('./images', true, /\.png$/);

    require.context makes webpack aware of the image urls so that we can use them throughout the json data as realative urls
    other than that all json

    parts object is a constant that is exported at the bottom

    parts object is an object that is comprised of objects for heads, arms, bases, and torsos that are all arrays of the specific parts

    component needs to import this data
        ex  
        import avaiableParts from '../data/parts.js';

    return the avaiableParts as part of the data object
        return {
            avaiableParts,
        };

Using data in the template
    Some directives can take an "argument" denoted by a colon after the direcrtive name
    v-bind
        used to reactively update an HTML attribute
        binds attribute to data
    ex
        <img v-bind:src="availableParts.heads[0].src" title="head"/>
        allows us to use the data that was provided to us in avaiableParts

Binding to events with v-on
    v-on
        listens to DOM events and runs JavaScript when they're triggered

methods
    object passed to the component options

Vue calls selectNextHead function via v-on
function increments the data
binding updates the attribute using it

Helper functions can be written in the script section of components before the export
    same place imports happen

Using Shorthand Bindings
    v-bind
        : shorthand for it
    v-on
        @ shorthand for it

Binding to Computed Properties
    don't do computed properties in template

Computed
    option on the component that contains methods

    use in script (move it into the component)
    computed: {

    },

Displaying Data with Interpolation
    displaying an attribute (name) of a computed property

    double brackets used for Interpolation
        {{}}
    can place valid expressions in the doubl brackets

v-once
    any bindings in element is only rendered once
    good for performance
    use on things that will not change

Conditionally displaying content with v-if and v-show

v-if
    the element is removed from the DOM if the condition evaluates to false

v-show
    display none is added to the element if the condition in v-show evaluates to false

v-show is used when the content being shown and hidden is expensive to calculate and hidden or show frequently
    efficenecy thing

Repeating Elements with v-for


Vues change detection works by hooking into the getters and setters of properties in the data property
    data must be in the data function if you want a change to happen on the page when the data changes

Object.assign
    good javascript programming practice that avoids inadvertent pointers to the same object instance

v-for
    goes on an element
    get a new element for each loop
    works like foreach
    ex
        <tr v-for="robot in cart">
        </tr>

    robot can be used as a variable within this element

    When ever you are repeating data vue needs to be able to identify each element in there for updates
        thus need a unique key attribute for repeated data
    ex  
        <tr v-for="(robot, index) in cart" :key="index">
            <td>
                {{ robot.head.title }}
            </td>
            <td class="cost">
                {{ robot.cost }}
            </td>
        </tr>
        we can get the index of the robot with the (robot, index)
        we then bind this index to the key with a v-bind

performance warning
    never use v-for and v-if on the same element

    if you need to hide and show data on v-for need to internal element or something like that

Styling Components
    Can use the style section to style components

index.html
    generated by the cli
    body element lives here
    this file is loaded when app first loads

    it contains app element that render function is binding to

scoped
    attribute on style tag
    sets the styles in style element to be restricted to the component the style element is a part of

    is adding hashed data attributes
        then styles in the components are only added to the elements that have the data attribute

Global styles
    should only be in top level component

Components can have multiple style blocks
    one scoped
    one global

Styling Child Components
    scoped style vue will not apply styles to elements out of scoped
    however, css inhieritance can still apply

    number of css properties that get inhiered

    style a parent component that wraps a child component can cause css inheirtance to apply styles to child components

    you can use the root component of the child component to apply styles to child components

>>> Deep Selector
    can target specific elements of child class from the parent by using class of the child component root >>> then class name
    this goes down to all children below parent
    ex
        .content >>> .robot-name

Conditionally Applying Styles with Style Bindings
    simply binding to the style attribute

    css attributes that have '-' require square brackets in when doing this
        b/c this is object notation
    ex  
        :style="{[background-color]: 'red'}"
    OR
        Vue allows use of camelCase for this

    can set attribute of style to a computed value to make it conditional
        the computed value returns object notation of the style attribute you want

    Can send an array to the style attribute you bound to
        first ele of array will be overridden by following styles
    ex  
        :style="[computedValueOne, computedValueN]"

Conditionally Applying Classes with Class Binding
    binding where keys are the class you want to toggle
    set it to a boolean expression that evaluates to true when you want the class applied
    ex
        :class="{'sale-border': selectedRobot.head.onSale}"    

    Add property for every class you want to toggle

    Can move above to computed property

    Array Syntax
        can place multiple in an array and all will be applied
    ex
        :class="[saleBorderClass, 'top', 'part']"

        saleBorderClass is a computed property that returns a class string when a condition is methods

        'top' and 'part' are always applied as they are just class strings

Using SASS and other CSS pre-processors
    cmd:
    npm install node-sass sass-loader --save-dev

    specify language in style tag
    ex
        <style lang="scss" scoped>
        </style>

Using Component Lifecycle Hooks
    can take action based on lifecycle states of a component

    typical use case
        fetch data from API when component is first created

    Created 
        add created function in export

    Handful of lifecycle hooks
        https://vuejs.org/v2/guide/instance.html
        diagram in above documentation

Mixins
    way to share functionality across multiple components

    any component option can be extracted out into a mixin file
    when mixin is imported they will be merged into the rest of your component options

    created-hook-mixin.js
        simply exports and object

    to use import it
    import createdHookMixin from './created-hook-mixin';

    then add it to the mixins array
    mixins: [createdHookMixin],

    can be used in multiple components

    can use a mixin to share any component options across many components
        including lifecycle hooks, props, computed propertier ect.

Summary Module 3
    Creating components
    Using bindings to display data and handle events
    ...

Module 4
Intercomponent Communication
    Using props to share data with child components
    Validating components with props
    Passing data to parents components with events
    Injecting content into a child component with slots

Creating Child Components
    refactoring part selector code into child component

    ie
        <div class="left part">
            <img :src="selectedRobot.leftArm.src" title="left arm"/>
            <button @click="selectPreviousLeftArm()" class="prev-selector">&#9650;</button>
            <button @click="selectNextLeftArm()" class="next-selector">&#9660;</button>
        </div>

    taking above and moving it into its own component with data passed into it from robot builder

    when referencing a child component it must be imported and listed as a component in the components option of the parent
        this makes the parent component aware of and able to be used in its template
    ex  
        shorthand
        components: { PartSelector },
        long
        components: { PartSelector: PartSelector },

Using Props to Share Data with Child Components
    bind data from the parent to an attribute of the child  
        need to create the attribute on the child
    
    props: []
        used to add attributes to a component
        ex
            props: ['parts'],

    Not all attributes need binding only ones that are attributes that are getting expressions passed along

Validating Props
    prevent parents components from passing in bad data

    use a key object for props instead of array
        keys are the names of the props
        values are objects that specify validation information

    Error will now show on browser console warning of invalid data type on a prop

    can also make props required

Validator Function
    specifies what a specific prop can be
    ex
        string can not be blank
        validator(value) {
            return ['left', 'right', 'top', 'bottom', 'center'].includes(value);
        },
        placed on the prop

Passing Data to Parent Component with Events
    Create events in the child component that the parent component can bind to

$emit
    causes the component to 'emit' and event on itself to binded listeners
    ex 
        this.$emit('partSelected', this.selectedPart)

        a parent component can now bind to the partSelected event when it created the component
        passes this.selectedPart up to the parent

    parents bind to emit event with v-on
        just like any other event
    ex
        @partSelected="<inline or function>"

        inline
        @partSelected="part => selectedRobot.head=part"/>

Updated()
    lifecycle hook called whenever the data for the component is updated

Injecting Content into a Child Component with slots

<slot></slot>
    vue specific element
    content that is placed inside of the component with the slot element will be placed where the <slot></slot> is in the component

     default content can be provided to a slot
        place content in between the slot tags on the component

Summary Module 4
    ...

Routing from Page to Page
    Adding routing to app
    Linking to routed pages
    Styling links based on the active route
    Navigating from code
    Working with route params
    Using nested routes
    Using named views
    Enabling HTML5 History mode
    Preventing navigation with navigation guards

Adding Routing to your App
    npm install vue-router --save
        install view router via the cli in a vue project

    need a place to define all of the routes in the app
        creating router folder

    index.js file  
        import Vue from 'vue';
        import Router from 'vue-router';

        Vue.use(Router);

        export default new Router({
            place routes here
        });
    lets vue know the app will be using routing

Router with routes
    export default new Router({
        routes: [{
            path: '/',
            name: 'Home',
            component: HomePage,
        }],
    });
    tells vue when on the url ('/') then load the specified component (HomePage)
    the name is used in code to navigate to the route

Need to pull routes in when we create vue instance so that vue is aware of them
    add it to the vue configuration object

Must tell App where to display routed components

<router-view></router-view>
    displays the component that matches the current route

Vue adds a hashtag to URL ad navigates based on what after that
    this will be removed later with HTML 5 history mode

Linking to Routed Pages
    <router-link></router-link>
        vue specific element to link to a routed page

    ex
        <router-link :to="{name: 'Home'}">
    use binding to access the route via the route name

    <router-link to="/build">
    can also use hard coded strings of the url you want

Styling Links Based on the Active Route

.router-link-active
    special vue class that is applied to any link that matches the current route
    by default this is an inclusive match on the route

    can add exact attribute on router-link to match route exactly for Styling

    can use active-class="" attribute if you don't want to use the .router-link-active class

Navigating from Code
    this.$router
        available on any component when you pass a router into the Vue instance

    .push('url to nav to ')
        sends to the specified url

    ex
        this.$router.push('/part');
    sends site the the /part url
    this example uses a string url can alternatively pass on object

Working with Route Params
    :<varName>
        used in routes file to specify router params
    ex 
        {
            path: '/parts/:partType/:id',
            name: 'Parts',
            component: PartInfo,
        },
    partType and id are vars

    route params are avaiable on the components route property
    ex
        this.$route.paramName

Destructuring
    this:
        const partType = this.$route.params.partType;
        const id = this.$route.params.id;
    can become
        const { partType, id } = this.$route.params;

    that is Destructuring params are assigned to the vars in order

Params that are pulled off of a url are always strings

Must use object syntax to pass Route Params

Navigating from Code with Route Params
    ex
        <img @click="showPartInfo()" :src="selectedPart.src" title="arm"/>
        showPartInfo() {
        this.$router.push({
            name: 'Parts',
            params: {
            id: this.selectedPart.id,
            partType: this.selectedPart.type,
            },
        });
        },

Passing Params as Props
    const { partType, id } = this.$route.params;
        downside couples component to the router

    Can make it work as a routed component and a child component by passing the params as props
        set the props property to true on the route

props: true,
    router property
    tells vue to pass the route params as props to the component

    in the component you can now get the params off of this instead of this.$route.params

    can add validation to the props this way
        by making the props an object containing the params

Nested Routes
    Allow portion of page to be rerender and change the url

    Using another router-view in the component
        add another route that consists of a parent route for the BrowseParts Page and a child route for the type of part

    this route needs to go above the /parts/:partType/:id route

    reason:
        {
            path: '/parts/browse',
            name: 'BrowseParts',
            component: BrowseParts,
        },
        {
            path: '/parts/:partType/:id',
            name: 'Parts',
            component: PartInfo,
            props: true,
        },
    Vue has no idea that 'browse' isn't a part type so its needs to go first so that it can match before reaching the second /parts/:partType

    order is important

    child route ex:
    {
      path: '/parts/browse',
      name: 'BrowseParts',
      component: BrowseParts,
      children: [
        {
          name: 'BrowseHeads',
          path: 'heads',
          component: RobotHeads,
        },
        {
          name: 'BrowseArms',
          path: 'arms',
          component: RobotArms,
        },
      ]
    }
    add the children array to a route

    the paths for the child routes are relative to the parent
    ex
        absoulte path for arms /parts/browse/arms

    child route router-link ex
        <router-link :to="{name: 'BrowseHeads'}">Heads</router-link>
    can simply use the name of the child route when binding

Using Named Views
    think of as sibling routes
    allow multiple router views on the same component
        the route specifies which two or more vues to display

    router-view s that are not given a name by default have the name default

    components property get added to the route
        this replaces component

        it takes a keyed object with the keys being the router-view names and the values being the component to display
    ex  
        {
            path: '/',
            name: 'Home',
            components: {
                default: HomePage,
                sidebar: SidebarStandard,
            },
        },

    feel like more depth could be needed on this

Enabling HTML5 History Mode
    hashtag is in urls because HTML5 history mode is off

    how to turn off
        mode: 'history',

        needs to be set in the router config object
            in index.js (router file)

    Consequence
        causes the full url to be sent to the server

        because server has no files at the full url in its directory it will 404

    hashtag causes only the part before the hashtag to be send to the server with the rest handled client sidebar
        this works because vue doesn't have anything at the directory of the full url. but it does have index files that know how to handle it

    Solution
        set up server to always return the main index.html file whenever you load in a url

        more on this in deploying to production

Preventing pages from Loading with Navigation Guards
    allow you to prevent a page from or prevent a user from leaving a page based on specific criteria

Before Enter Guard
    prevent page from loading if :id in route param isn't a number

    different from validation as validation still loads the page and only throws a dev warning

    can add a route-guard on a component or a route

    how to add on a route
        add a beforeEnter() on the keyed route object
    
    beforeEnter(to, from, next)
        to:
            the route to navigate to
        from:
            the route you are navigating from
        next function
            called with a value of true to allow navigation
            called with a value of false to stop navigation

        can get params from the to route
        
    ex
        {
            path: '/parts/:partType/:id',
            name: 'Parts',
            component: PartInfo,
            props: true,
            beforeEnter(to, from, next) {
                const isValidId = Number.isInteger(Number(to.params.id));
                next(isValidId);
            },
        },

Preventing Navigation Away From Pages With Navigation Guard 
    Can be on the route or the component

    example we will do needs information from the component so we will make it on the component

beforeLeave()
    when adding on a component it becomes beforeRouteLeave()
        same thing for Enter

    to, from, next
        params

Summary Module 5
    Adding routing to app
    Linking to routed pages
    Styling links based on active route
    Navigatin from code
    ...

Managing State and Server Communication with Vuex
    How to handle data

    The Vuex Store
        Storage mechnism
        interface for mutating data, requesting async mutations, managing complex logic

        Shared State Tree
            Single object that contains all of the data for your application

        Mutations
            synchronous 
            tells the store to commit a mutation, keeps everything in the store consistent and working well with change detection

        Actions
            Asynchronous
            Can get data from apis
            work hand in hand with mutations
            promises,

        Getters 
            functions that fetch data on the state
            does calculation or manipulation on them

Creating a Vuex Store

Installing Vuex
    npm install vuex --save

Create a Vuex Store
    store folder
    index.js
        import vue and vuex

        Vue.user(Vuex);

        export default new Vuex.Store({

        });

main.js
    the main JavaScript files that drive the vue app
    this is where the Vue instance is created

Changing a Vuex Store State with Mutations
    store needs a state object
        this is where the data will restricted
        everything that is added to the store must start with a default value
            change detection works by tapping into getters and setters of objects in store. With no default property vue will not notice changes

    ex add cart property to state object
        export default new Vuex.Store({
            store: {
                cart: [],
            },
        });

mutations object 
    Property of a vuex state
    All changes must go through a mutation

    ex
        mutations: {
            addRobotToCart(state, robot) {
                state.cart.push(robot);
            },
        },

    mutation params
        state

        robot 
            all remaining parameters after state are data you want to pass in

Calling Mutation
    $store
        can access store this way because global vue instance is aware of the store

    .commit('name of mutation', data to pass into store)

Retreiving Items from the Vuex Store
    use a computed property to get data from the store
    ex
        computed: {
            cart() {
            return this.$store.state.cart;
            },
        },
    Can't mutate a vuex store directly but you can access a vuex store directly to read from

Using Vuex Getters to Return Calculated Data
    can do any calculation from state that you want to
    Can be added as getters to store to make them reuseable
    
    state
        first param of getters
    ex
        getter: {
        cartSaleItems(state) {
            return state.cart.filter(
                item => item.head.onSale
                || item.torso.onSale
                || item.leftArm.onSale
                || item.rightArm.onSale
                || item.base.onSale,
            );
        },
    Based on data in the state and exposed as cartSaleItems getter

Accessing getters from component
    this.$store.getters.cartSaleItems;

Using Actions to Work with APIs and Asynchronous Data

Action
    Asynchronously get data from API

    context
        first param
        exposes serveral items for working with the state
        ex
            actions: {
                getParts(context) {

                },
            },
        you can desconstruct out of this object
        ex
            actions: {
                getParts({commit}) {

                },
            },
        got only the commit function out of the context
        other things you can get from context: state, getters, commit, dispatch

commit
    how we call mutations on the store

Vue doesn't provide any of its own custom data access libraries to make HTTP calls
    instead allow you to use whatever you want

Axios
    how to install 
        npm install axios --save

    import in store and you can use it to get data

    .get(url)
        url
            the url you want to hit with HTTP get request


    vue provides a way to configure a built in proxy to hit our APIs
    can proxy api through dev server that our vue app is being served from 

Proxy Vue API
    configuration
        vue.config.js
    this is webpack config vue uses this behind the scenes
    with what is in there axios.get('/api/parts'); now get proxied to the server running on port 8081

    Need to restart server when you update proxy config

Where ever data form action is needed you must dispatch the action

.dispatch 
    store function
    kicks off actions

    async call to get the store to get the parts
    can then get these parts from the store using a computed property

    created a mixin that is using dispatch to get parts via a computed prop
    
Data folder is no longer need as this is all coming from an API

Using Actions to Save Data to an API
    actions takes state, which can be deconstructed, and data to be sent to API
    ex
        actions: {
            addRobotToCart({ commit, state }, robot) {
                const cart = [...state.cart, robot];
                axios.post('/api/cart', cart)
                    .then(() => commit('addRobotToCart', robot));
            },
        }
    adds robot to cart on server via axios.post('/api/cart', robot)
        sending cart to the /api/cart end point
    adds robot to store so local app reflects change as well via the promise .then(() => commit('addRobotToCart', robot))
        the promise takes a function that gets run after API succeeds which uses commit to mutate store data

commit mutations, dispatch actions

Returning Promises from Actions
    can return the promise from the action, then are able to use the promise from the components that dispatch the action
        ie you can use .then after the dispatch in the component to do something on success/fail

Organizing the Store with Modules

Modules
    Allow a single store to be broken up into multiple modules for maintainability

    modules: {}
        property on the Vuex.Store 
        ex
            modules:{ 
                robots: robotsModule
             },
        robotsModule needs to be imported from the .js file that contains the module

    modules can be accessed from components in the following example
        this.$store.state.robots.cart;
            note robots is the name of the module on the $store
    
    There is still a single state object and in it there is a robots module

Namespacing Modules
    without namespaces vue doesn't know which module a dispatch belongs to
    all modules with a matching action will respond

    namespaced
        property on module
        namespaced: true,

        requires a namespace before an action name on dispatch calls
        ex
            this.$store.dispatch('robots/addRobotToCart', Object.assign({}, robot, { cost }))
        the robots/ is the namespace before the name of the action

State
    always namespaced even if module is not namespaced

Mutations, Actions, Getters
    only namespaced if namespaced is true

Accessing Namespaced Getters
    use a string to access the property prefacing it with namespace/
    ex
        this.$store.getters['robots/cartSaleItems'];
    robots/ is the namespace here

Understanding Global and Namespaced State
    one single state tree or state object

    root state
        state that is not in a namespaced module

    getters are shared with root if not Namespaced
        thus if root and unnamespaced module have the same getter name it will error

    State passed into getters, actions, mutations within module is always the local modules state

Getters 
    Params
        state
            local state
        getters
            in non namespaced
                all getters
            in namespaced
                only local getters
        rootState
            the root's state
    ex
        getters: {
            foo(state, getters, rootState) {
                return ${rootState.foo};
            }
        }
    this returns the root state's foo object

rootState
    accessible by getters and actions
    not accessible by mutations

Using Vuex MapState Helper 
    used in computed section of component

    import { mapState } from 'vuex';

    export default {
        name: app,
        computed: {
            ...mapState({ rootFoo: 'foo' })
            rootFoo() {
                return this.$store.state.foo;
            },
        }
    }

    note that lines
        ...mapState({ rootFoo: 'foo' })

    and 
        rootFoo() {
            return this.$store.state.foo;
        },
    are equivalent

    to get mapState from modules
        ...mapState({ rootFoo: 'foo', usersFoo: state => state.users.foo });

        this would be the object foo from the root store and the object foo from the users module
    
    note
        usersFoo: state => state.users.foo 
    replaces
        usersFoo() {
            return this.$store.state.users.foo;
        }

    Second MapState Syntax
        this syntax only works with namespaced modules
        ...mapState('robots', { robotsFoo: 'foo' })
        'robots'
            is the namespace
        'foo'
            is the property from the namespace state
        robotsFoo
            var for above

    Note that can replace
        robotsFoo() {
            return this.$store.state.robots.foo;
        }

Using Vuex MapGetters Helper
    identical to using MapState
    used in computed section of component

    import { mapState, mapGetters } from 'vuex';
        not can import either one on its own

    ...mapGetters({rootGetterFoo: 'foo'});
    ...mapGetters('robots', { robotsGetterFoo: 'foo' });

    replace
        rootGetterFoo() {
            return this.$store.getters.foo;
        }
        robotsGetterFoo() {
            return this.$store.getters['robots/foo'];
        }

Using Vuex MapActions Helper
    slightly different
    used in the methods section instead of the computed section of a component

    import { mapActions } from 'vuex';

    ...mapActions('robots', ['getParts', 'addRobotToCart']),

    now these are methods here and we can call
        this.getParts
    replaces
        this.$store.dispatch('robots/getParts');
        
    mapActions helper takes care of calling dispatch for us

    now
        this.addRobotToCart(Object.assign({}, robot, { cost }))
            .then(() => this.$router.push('/cart'));
    replaces
        this.$store.dispatch('robots/addRobotToCart', Object.assign({}, robot, { cost }))
            .then(() => this.$router.push('/cart'));

Using Vuex MapMutations Helper
    used in methods section

    import { mapMutations } from 'vuex'

    ...mapMutations('module name', ['someMutation']);

    module name, array of mutations to map over
    can use object notation also if you want to rename locally
    ex  
        ...mapMutations('module name', { localName: 'someMutation' });

Summary Module 6
    Vuex

Creating Custom Directives and Filters
    Creating and using custom directives
        such as v-if
    Passing data to directives
    Declaring directives locally vs globally
    Creating and using Filters
    Filters locally vs globally

Creating a Custom Directive

Directive
    A special token in the markup that tells the library to do something to a DOM element

    A vue.js directive can only appear in the form of a prefeixed HTML attribute with the following format
        <element
            prefix-directiveId="[argument:] expression [| filters...]">
        </element>
    
    simple example
        <div v-text="message"></div>

    v
        prefix which is the default
    text
        the directive id
    message
        the expression

    this one instructs Vue to update the textContent whenever the message property on the Vue instance changes

Creating our own directives
    directive have a handful of methods that act as hooks

    bind:
        this is a hook
        gets called as soon as a directive get bound to its parent element

        first param is element
            the parent element itself (in PartsSelector v-pin example this is the span it is on)

    created in a js file
    ex
        export default {
            bind: (element) => {
                element.style.position = 'absolute';
                element.style.bottom = '5px';
                element.style.right = '5px';
            },
        };
    that is a directive that changes a couple styles on the parent element

    to use a directive in a component import it and at it to the directives property
    ex
        import pinDirective from '../shared/pin-directive';

        directives: {
            pin: pinDirective,
        },

    Note v- get prepended automatically

Passing Data to Directives
    multiple ways to pass data to directives

via Args
    v-pin:position.top.right
        position
            is the argument
        .top.right
            are the modifiers

    binding 
        second param to directive
        gives access to the Args

    ex
         export default {
            bind: (element, binding) => {
                console.log('arg: ', binding.arg, 'modifiers: ', binding.modifiers);
                element.style.position = 'absolute';
                element.style.bottom = '5px';
                element.style.right = '5px';
            },
        };

    modifiers is an object with each modifer set to true if they exist

via Object
    v-pin="{ bottom: '10px', right: '5px' }"

    ex
        export default {
            bind: (element, binding) => {
                Object.keys(binding.value).forEach((position) => {
                element.style[position] = binding.value[position];
                });
                element.style.position = 'absolute';
            },  
        };

    binding.value loops over what is in the object passed in
        position becomes the keys bottom and right
        binding.value[bottom] = '10px'
        binding.value[right] = '5px'

Using Directive Lifecycle Hooks

    update:
        triggers when the parent component is updated

    ex
        function applyStyle(element, binding) {
            Object.keys(binding.value).forEach((position) => {
                element.style[position] = binding.value[position];
            });
            element.style.position = 'absolute';
        }

        export default {
            bind: (element, binding) => {
                applyStyle(element, binding);
            },
            update: (element, binding) => {
                applyStyle(element, binding);
            },
        };

    example uses a function to do the same thing when the directive is bound and the directive's parent component is updated
        same thing on two different lifecycle hooks

    inserted:
        fires when the bound element has been inserted into its parent node

    componentUpdated:
        fires after all children have been updated

    unbind:
        called when the directive is unbound from the parent component

bind and update are so common there is a shorthand to hook into both 
    ex
        export default function (element, binding) {
            Object.keys(binding.value).forEach((position) => {
                element.style[position] = binding.value[position];
            });
            element.style.position = 'absolute';
        }
    this is now binding to both the bind and update hooks

Making Directives Available globally
    so far we have only made directive avaiable to a single component
        this is good if it only relates to a single or couple components

    often directives are wanted through out the app
        better to declare these globally

    declare globally in the main.js file
    ex
        import pinDirective from './shared/pin-directive';

        Vue.directive('pin', pinDirective);
    import the directive and pass it in with a name to the Vue.directive function

Creating a Custom Filter
    allow easy transformation of data

    take data in as input and output something different

    filters are really just functions that take a minimum of one param

    ex
        export default function (amount) {
        
        }

    To Use
        add to the filters: property of a component
    ex
        filters: {
            currency: currencyFilter,
        },
    Note must import currencyFilter

    since filter are just functions can also import them inside component or anywhere else and use them as computed prop

Declaring Filters Globally
    in main.js
    ex
        import currecyFilter from './shared/currency-filter';

        Vue.filter('currency', currecyFilter);
    same as directive 

Summary Module 7
    custom directives
    data to directives
    local va global directive
    custom filter
    local vs global filter

Deploying Vue Applications to Production
    Basic with CLI build is a Zero Config build
        cane make a production build from it

Zero Config Deployment
    lots of good options

    can add or remove things from config

Creating a deployable build
    npm run build

    creates a deploy build with what CLI includes

    creates a deployable build folder
        dist/

    Just have to copy the dist/ folder to a place where it can be served by the web server

dist/
    css/
        came from the code we wrote
    js/
        came from the code we wrote
    img/
        came from the code we wrote
    index.html
        came from public folder
        this is the starting point for our application
    favicon.ico

anything placed in the public folder will go into dist/

Using Evironment Variables and Build Modes
    default mode
        npm run build -- --mode=production

    dev build
        npm run build -- --mode=development
            npm run serve does this

    staging
        npm run build -- --mode=staging

        app.js

        favicon.ico

        img/

        index.html

        .env.stagging
            NODE_ENV=production

        sets the node environment to be one that looks just like production
        npm run build -- --mode=staging

        can replace staging with any name

        .env vars can have other values like DB connections ect.
            NEVER commit secret ones
        
        env variables are only available to client side code if there start with VUE_APP
            with the exception of NODE_ENV

Deploying to Production
    adding routes to the server to be able to add a dist/ folder and have it serve production
        to the build-a-bot-server

    app.use('/', express.static('dist', {index: 'index.html'}))
        whenever anyone hits the route url and its not handled by routes aboe then serve the index.html file from this dist folder

    deploying a vue app is just copying the dist folder to your web app

    npm start
        starts the server

Deep Linking on the Server
    Can not navigate directly to deep urls because only the index.html file knows how to serve the vue app

    npm install connect-history-api-fallback
        middleware

    const history = require('connect-history-api-fallback');

    app.use(history({index: '/index.html'}));
    if a request come in for a file that is not handled in the routes below then redirect to /index.html

Inspecting the built in webpack config
    vue inspect --mode=production > webpack.config.js
        putting the webpack config to a file for us to view

Customizing Webpack Config
    add a section to our vue.config.js file

    configureWebpack: {
        modules: {
            rules: [
                test: /\.coffee$/,
                use: ['coffee-loader'],
            ]
        },
    },
    cli uses webpack chain and merge to add this to the file
    anything here will be added to or override 

    To edit rules
        copy and changing something can result in duplicates

        instead

    configureWebpack: (config) => {
        config.modules.rules.push({
            test: /\.coffee$/,
            use: ['coffee-loader'],
        })

        const newRule = {
            copied in rule with change here
        }

        const imagesRuleIndex = config.module.rules
            .findIndex(x => x.test.source.includes('png|jpe?g|gif'));

        config.module.rules.splice(imagesRuleIndex, 1, newRule);
    },
    set it to a function and pass in a config object
